// emmanuel.botros@gmail.com
new doubler,
  uriChan,
  insertArbitrary(`rho:registry:insertArbitrary`),
  stdout(`rho:io:stdout`),pouet, ackPouet,uriP,ackPV,ackP,i,RhobustContract,super,
  Object,
  RhobustContract, ret1, ret2, ret3, ackJoe,resJoe, ackIrs,resIrs, ackBoss,resBoss, ackInfo,resInfo,
  // myRhobustContractTEST : test rhobustFactory101
    // This level of recursivity is only needed to simulate a sequential test.
    // In real life, agents interact INDEPENDENTLY and sometimes CONCURRENTLY.
   myRhobustContractTEST, ack, stdoutAck(`rho:io:stdoutAck`) in {

 /*@"rhobustFactory102"!(*myRhobustContractTEST, 3) | 
            for(_ <- ack) {
                myRhobustContractTEST!("Joe", "secretkey_employee", *ack) | 
                for(res <- ack) {
                    stdoutAck!(*res, *ack) | 
                    for(_ <- ack) {
                        myRhobustContractTEST!("irs", "secretkey_irs", *ack) | 
                        for(res <- ack) {
                            stdoutAck!(*res, *ack) | 
                            for(_ <- ack) {
                                myRhobustContractTEST!("boss", "secretkey_employer" , *ack) | 
                                for(res <- ack) {
                                    stdoutAck!(*res, *ack) | 
                                    for(_ <- ack) {
                                        myRhobustContractTEST!("Sam", "dummy_key", *ack) | 
                                        for(res <- ack) {
                                        stdoutAck!(*res, *ack)
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }*/




    stdoutAck!("TEST : Creating sample rhobust contract", *ack) |
    stdout!(["RhobustContract: ",*RhobustContract]) |
    RhobustContract!("new",[Nil,{"title": "sample rhobust contract v1.0", "data": true},{},Nil,*ret1]) |
    for ( nod1 <- ret1) { 
        
        nod1!("get", ["title", *ackInfo])
        |
        for(resInfo <- ackInfo) {
            stdout!(*resInfo)
        }
        |
        nod1!("identify", ["Joe", *ackJoe])
        |
        for(resJoe <- ackJoe) {
            stdout!(*resJoe)
            |
            nod1!("identify", ["Irs", *ackJoe])
            |
            for(resJoe <- ackJoe) {
                stdout!(*resJoe)
                |
                nod1!("identify", ["Boss", *ackJoe])
                |
                for(resJoe <- ackJoe) {
                    stdout!(*resJoe)
                    | 
                    stdout!("ok")
                }
            }
        }
    }

|
  // get the uri of this RhobustContract from the registry
contract RhobustContract(this, @"register", @[*ret]) = {
    new RhobustContractChan, uriChan, insertArbitrary(`rho:registry:insertArbitrary`) in {
        for( @RhobustContract <- this) {
            if (RhobustContract.get("uri") != Nil ) {
                ret!(RhobustContract.get("uri")) |
                this!(RhobustContract)
            } else {
                insertArbitrary!(*this, *uriChan) |
                for(@uri <- uriChan) {
                    stdout!(["RhobustContract",uri]) |
                    this!(RhobustContract.set("uri",uri)) |
                    ret!(uri)
                }
            }
        }
      }
    }
  | contract Object(class, @instance, ret) = {
    new this in {
      ret!(bundle+{*this}) |
      //instance methods
      contract this(@method, args) = {
        class!(instance, method, *args)
      }
    }
  } |
    contract RhobustContract(@"new", @[ // class method to create a new RhobustContract
           super, // RhobustContract to query for links not found in current nde
           propsMap, // property map of RhobustContract attributes
           linkMap, // map of named links from RhobustContract
           owner, // public key of owner TODO identity and encryption TBD
         *return]) = { // return the address (name/channel) of the new RhobustContract Object
      new instance, ret in {
        stdout!(["new",{"super": super, "props": propsMap, "links": linkMap, "owner": owner }, *instance]) |
        Object!(*RhobustContract, *instance, *ret) |
        for ( @object <- ret ) {
          instance!({"object": object, "contract": bundle+{*RhobustContract}, "super": super, "props": propsMap, "links": linkMap, "owner": owner }) |
          return!(object)
        }
      }
    }|
    // get a property value from this RhobustContract
    contract RhobustContract(this, @"get", @[name, *value]) = {
      for (@nod <- this) {
        this!(nod) |
        value!(nod.get("props").get(name))
      }
    }
    // set a property value from this RhobustContract
  | contract RhobustContract(this, @"set", @[name, value, *ack]) = {
      for (@nod <- this) {
        this!(nod.set("props",nod.get("props").set(name,value))) |
        ack!(Nil)
      }
    }
    |
    // identify someone using RhobustContract
    contract RhobustContract(this, @"identify", @[name, *ack]) = {
      for (@nod <- this) {
        this!(nod) |
        ack!("identify "++ name ++ " ok")
      }
    } 
  }
|
    contract @"rhobustFactory102"(rhobustContract, @n) = {
        new pay, invoiceId, invoiceAmount, invoiceName, processIncomeTax, widthdraw, taxPay,
        ri(`rho:registry:insertArbitrary`), 
        rl(`rho:registry:lookup`),
        stdout(`rho:io:stdout`),
        stdoutAck(`rho:io:stdoutAck`), ack, countCh, logResolve, logTransaction,myRhobustContractTEST, ack,
    rhobustContract,
    uriChan,
    insertArbitrary(`rho:registry:insertArbitrary`),
    testContract,testContractUri,uriChan in {
            
            // simple log method
            contract logResolve(@message, cb) = {
                cb!(message)
            } |
            
            // simple log methodH, "payment", name, "employer", amount," << salary payed ! (AGENT A)"
            contract logTransaction(@tid,@action,@nameWorker,@nameCurrentAgent,@amount,@message)= {
                stdout!(["transaction id:",tid,"action:",action,"nameWorker:",nameWorker,"nameCurrentAgent:",nameCurrentAgent,"amount:",amount,"message:",message])
            } |

            // rhobust contract
            contract rhobustContract(@agentType, @secretKey, result) = {
                //countCh!(1) |
                //for(@oldCount <- countCh) {
                    if (agentType == "boss" and secretKey == "secretkey_employer") {
                        // agent A (Employer) has been identified
                        pay!(*invoiceId, *invoiceName, *invoiceAmount, "Joe", 100)
                        |  // <- concurrent
                        logResolve!("Hello " ++ agentType ++ ", let's pay Joe. transaction will be fullfiled using your key ${secretKey}" %% {"secretKey": secretKey}, *result)
                    } else 
                    if (agentType == "Joe" and secretKey == "secretkey_employee") {
                        // agent B (Employee) has been identified
                        logResolve!("Hello " ++ agentType ++ ", you will get payed soon. transaction will be fullfiled using your key ${secretKey}" %% {"secretKey": secretKey}, *result)
                    }  else 
                    if (agentType == "irs" and secretKey == "secretkey_irs") {
                        // agent C (IRS) has been identified
                        logResolve!("Hello " ++ agentType ++ ", tax income will be transfered soon. transaction will be fullfiled using your key ${secretKey}" %% {"secretKey": secretKey}, *result)
                    } else {
                        // NOTHING happens otherwise
                    }
                //}
            }|

            // when a payment occurs, these three actions are triggered .. CONCURRENTLY !!
            for(@paymentId <- invoiceId;@paymentName <- invoiceName;@amount <- invoiceAmount) {
                // required inputs have matched ! the payment has been done.
                
                // agent B (Employee)
                widthdraw!(paymentId, paymentName, amount/2, *ack)
                |  // <- concurrent
                // agent B (Employee)
                taxPay!(paymentId, paymentName, amount/2, *ack)
                |  // <- concurrent         
                // agent C (Tax Services)
                processIncomeTax!(paymentId, paymentName, amount/2, *ack)      
            } |

            // agent A (Employer) behaviour : pay
            contract pay(pId, pName, pAmount, @name,@amount) = {
                new Y, H in {
                // generate new transaction hash key
                @"keccak256Hash"!(name.toByteArray(), *Y) 
                    |  // <- concurrent key generation and key receiver channel creation
                for (@H <- Y) { // we have a key
                    logTransaction!(H, "payment", name, "employer", amount," << salary payed ! (AGENT A)")
                    | 
                    pId!(H) | pName!(name) | pAmount!(amount) // fullfill the payment (4 independent processes are spawned)
                }
                    }
            } |

            // agent B (Employee) behaviour : widthdraw
            contract widthdraw(@uri,@name,@amount, result) = {
                new paymentIdLookupResponse in {
                    // todo : code the widthdraw of @amount salary 
                    logTransaction!(uri, "withdraw", name, "employee", amount, " << got payment. can widthdraw ! (AGENT B)") |
                    result!("ok")
                }
            }|

            // agent B (Employee) behaviour : taxPay
            contract taxPay(@uri,@name,@amount, result) = {
                new taxPaymentOut in {
                    // todo : code the payment of @amount of taxes
                    logTransaction!(uri, "tax_payment", name, "employee", amount, " << tax payed ! (AGENT B)") |
                    result!("ok")
                }
            }|

            // agent C (Tax Services) behaviour : processIncomeTax
            contract processIncomeTax(@uri,@name,@amount, result) = {
                new taxPaymentIn in {
                    // todo : code the income of @amount taxes 
                    logTransaction!(uri, "tax_income", name, "IRS", amount, " << tax secured ! (AGENT C)") |
                    result!("ok")
                }
            }
    }
    }
    
    //} |
    ///////
    