// emmanuel.botros@gmail.com
/////////////////////////
// myRhobustContractTEST : test rhobustFactory102

import MakeMint in {
    Nil
} |

new myRhobustContractTEST, myRhobustContract_Joe , myRhobustContract_Irs , myRhobustContract_Boss, ack, stdout(`rho:io:stdout`), stdoutAck(`rho:io:stdoutAck`),
ackJoe, resJoe, 
ackIrs, resIrs, 
ackBoss, resBoss,
ackCoop, resCoop,
myRhobustContract_Coop,
resProc_Joe,ackProc_Joe,
resProc_Irs,ackProc_Irs,
resProc_Boss,ackProc_Boss,
resProc_coop,ackProc_Coop,
aliceWalletBalance,bobWalletBalance,
getMintA,getMintB,getMintC, getPurseA,getPurseB,getPurseC,getPurseD,getBalanceA,getBalanceAB,getBalanceB,getBalanceC,getBalanceD,ccDep1 ,ccDep2,ccDep3 ,ccDep4,ccDep5 ,ccDep6,ackBoss2 in {

    // TEST RhobustContracts
    // The level of recursivity shown in this test is needed to simulate sequential actions of each agent
    // In real life, agents interact INDEPENDENTLY and sometimes CONCURRENTLY.
    // in Rholang, concurrency is handled gracefully. this is why simulating sequencial actions is harder ^^
    stdout!("TEST STEP 1 : Creating sample rhobust contract") | 
    @"RhobustFactory"!(*ack) |
    for(@uri2 <- ack) {

        @"RhobustContractorFactory"!({"uri":uri2,"name:":"Joe", "amount": 10000}, *getPurseA) |
        @"RhobustContractorFactory"!({"uri":uri2,"name:":"boss", "amount": 10000}, *getPurseB) |
        @"RhobustContractorFactory"!({"uri":uri2,"name:":"irs", "amount": 10000}, *getPurseC) |
        @"RhobustContractorFactory"!({"uri":uri2,"name:":"coop", "amount": 10}, *getPurseD) |
        for (@purseJoe <- getPurseA;@purseBoss <- getPurseB;@purseIrs <- getPurseC;@purseCoop <- getPurseD) {
            //purse check..
            @[purseJoe, "getBalance"]!(*getBalanceA)
            | for(@balanceJoe <- getBalanceA) {
                stdout!(["Joe BEFORE", balanceJoe])
            } |
            @[purseIrs, "getBalance"]!(*getBalanceB)
            | for(@balanceIrs <- getBalanceB) {
                stdout!(["irs BEFORE", balanceIrs])
            } |
            @[purseBoss, "getBalance"]!(*getBalanceC)
            | for(@balanceBoss <- getBalanceC) {
                stdout!(["boss BEFORE", balanceBoss])
            } |
            @[purseCoop, "getBalance"]!(*getBalanceD)
            | for(@balanceCoop <- getBalanceD) {
                stdout!(["coop BEFORE", balanceCoop])
            } |
            
            // uri2 is sent to all 3 agents.

            // Agent A (Joe) stores uri2 in a safe place
            // Agent B (IRS) stores uri2 in a safe place
            // Agent C (boss) stores uri2 in a safe place
            // Agent D (coop) stores uri2 in a safe place

            
            // Later on, agent A (Joe) logs in to sign the contract
            // this results in a lookup in the tuplespace using uri
            @"RhobustFactorySign"!(*myRhobustContract_Joe, uri2,"sign", "Joe","secretkey_employee", *ackJoe) |
            for(resJoe <- ackJoe) {
                stdout!(*resJoe) |
            
                // Later on, agent B (irs) logs in to sign the contract
                // this results in a lookup in the tuplespace using uri
                @"RhobustFactorySign"!(*myRhobustContract_Coop, uri2,"sign",  "coop","secretkey_coop", *ackCoop) |
                for(resCoop <- ackCoop) {
                    stdout!(*resCoop) |
                
                    // Later on, agent B (irs) logs in to sign the contract
                    // this results in a lookup in the tuplespace using uri
                    @"RhobustFactorySign"!(*myRhobustContract_Irs, uri2,"sign",  "irs","secretkey_irs", *ackIrs) |
                    for(resIrs <- ackIrs) {
                        stdout!(*resIrs) |
                
                        // Later on, agent C (boss) logs in to sign the contract
                        // this results in a lookup in the tuplespace using uri

                        // identify
                        @"RhobustFactorySign"!(*myRhobustContract_Boss, uri2,"sign",  "boss","secretkey_employer", *ackBoss) |
                        for(resBoss <- ackBoss){

                            // pay
                            @"RhobustFactoryPay"!(*myRhobustContract_Boss, uri2,"pay",  "boss","secretkey_employer", 5500, purseBoss, purseJoe, purseIrs, purseCoop, *ackBoss2) |
                            
                            for(@res2<-ackBoss2) {
                                stdout!(res2.get("c")) |
                                
                                // CHECK BALANCES
            
                                @[purseJoe, "getBalance"]!(*getBalanceA)
                                | for(@balanceJoe <- getBalanceA) {
                                    stdout!(["Joe  AFTER", balanceJoe])
                                }
                                |
                                @[purseBoss, "getBalance"]!(*getBalanceB)
                                | for(@balanceBoss <- getBalanceB) {
                                    stdout!(["boss AFTER", balanceBoss])
                                }
                                |
                                @[purseIrs, "getBalance"]!(*getBalanceC)
                                | for(@balanceIrs <- getBalanceC) {
                                    stdout!(["irs  AFTER", balanceIrs])
                                }
                                |
                                @[purseCoop, "getBalance"]!(*getBalanceD)
                                | for(@balanceCoop <- getBalanceD) {
                                    stdout!(["coop  AFTER", balanceCoop])
                                }
                            }
                        }
                    }
                }
            }
        } 
    }
} |

new
stdout(`rho:io:stdout`),
ri(`rho:registry:insertArbitrary`), 
rl(`rho:registry:lookup`),
stdoutAck(`rho:io:stdoutAck`),
RhobustContract,
RhobustContractor,
Object, 
contractCh,
ackContract,  
ackInfo,resInfo,
ackRegister,
resRegister,
ackRl,resRl,
ack, ackContractCh,
pay, ackPay,
invoiceId, invoiceAmount, invoiceName, 
processIncomeTax, widthdraw, taxPay, 
logResolve, 
uriChan, uriChan2, uri2,
logTransaction,
agentType,secretKey,
ackwithdraw,acktaxPay,ackprocessIncomeTax,
RhobustContractSign,ackRhobustContractSign,
RhobustContractPay,ackRhobustContractPay,
uriPChan,getPurse,mint, p1, p2,ccDep1,ccDep2,sccDep1,sccDep2,sccDep3,sccDep4,sccDep5,sccDep6,sccDep7,sccDep8
in {
    
    contract @"RhobustFactory"(result) = {
        new 
        ri(`rho:registry:insertArbitrary`), 
        rl(`rho:registry:lookup`) in {
            // store the contracts
            ri!(bundle+{*RhobustContract}  , *uriChan) |
            for(@uri <- uriChan) {
                // lookup again using uri
                rl!(uri, *contractCh) |
                for( ct <- contractCh) {
                    ct!("new",[{"contract_id": uri, "data": true},*ackContract]) |
                    for ( myContract <- ackContract) { 
                        // store the instance of the contract
                        ri!(bundle+{*myContract}  , *uriChan2) |
                        for(@uri2 <- uriChan2) {
                            // send back the final contract instance uri
                            result!(uri2)
                        }
                    }
                }
            }
        }
    } |

    contract @"RhobustContractorFactory"(@props, result) = {
        RhobustContractor!("new",props.get("amount"),[{"contract_uri": props.get("uri"), "name": props.get("name"), "starting_balance": props.get("amount"), "data": true},*result])

    } |

    contract @"RhobustFactorySign"(rhobustLookup, @uri, @action, @name, @key, resultLookup) = {
        
        rl!(uri, *contractCh) |
        for( ct <- contractCh) {
            RhobustContractSign!(name, key, *ackRhobustContractSign) |
            for(@resRhobustContractSign <- ackRhobustContractSign) {
                resultLookup!(resRhobustContractSign)
            }
        }

    } | 

    contract @"RhobustFactoryPay"(rhobustLookup, @uri, @action, @name, @key,@amount,p1,p2,p3,p4, resultLookup) = {
        
        rl!(uri, *contractCh) |
        for( ct <- contractCh) {
            RhobustContractPay!(name, key, amount,*p1,*p2,*p3,*p4, *ackRhobustContractPay) |
            for(@resRhobustContractPay <- ackRhobustContractPay) {
                resultLookup!(resRhobustContractPay)
            }
        }

    } |
    
    // class method to create a new RhobustContract
    contract RhobustContract(@"new", @[
        propsMap,
        *return]) = { // return the address (name/channel) of the new RhobustContract Object
            new instance, ret in {
            stdout!(["new contract",{"props": propsMap}, *instance]) |
            Object!(*RhobustContract, *instance, *ret) |
            for ( @object <- ret ) {
                instance!({"object": object, "contract": bundle+{*RhobustContract}, "props": propsMap }) |
                return!(object)
            }
        }
    } |

    // get a property value from this RhobustContract
    contract RhobustContract(this, @"get", @[name, *value]) = {
        for (@nod <- this) {
            this!(nod) |
            value!(nod.get("props").get(name))
        }
    } |

    // set a property value from this RhobustContract
    contract RhobustContract(this, @"set", @[name, value, *ack]) = {
        for (@nod <- this) {
            this!(nod.set("props",nod.get("props").set(name,value))) |
            ack!(Nil)
        }
    } |

    // class method to create a new RhobustContractor
    contract RhobustContractor(@"new", @amount, @[
        propsMap,
        *return]) = { // return the address (name/channel) of the new RhobustContractor Object
            new instance, ret in {

                MakeMint!(*mint) |
                for(@m <- mint) {
                    
                    @[m, "makePurse"]!(amount, *getPurse) |
                    for (@p <-getPurse) {
                        // store purse
                        //ri!(bundle+{*p}  , *uriPChan) |
                        //for(@uri <- uriPChan) {
                            
                            stdout!(["new contractor",{"props": propsMap/*,"purse_uri": uri*/}]) |
                            Object!(*RhobustContractor, *instance, *ret) |
                            for ( @object <- ret ) {
                                stdout!("contractor object created !") |
                                instance!({"object": object, "props": propsMap }) |
                                return!(p)
                            }
                        //}
                    }
                }
            }
    } |

    // get a property value from this RhobustContractor
    contract RhobustContractor(this, @"get", @[name, *value]) = {
        for (@nod <- this) {
            this!(nod) |
            value!(nod.get("props").get(name))
        }
    } |

    // set a property value from this RhobustContractor
    contract RhobustContractor(this, @"set", @[name, value, *ack]) = {
        for (@nod <- this) {
            this!(nod.set("props",nod.get("props").set(name,value))) |
            ack!(Nil)
        }
    } |

    // PAY using RhobustContract
    contract RhobustContractPay(@agentType, @secretKey, @amount, p1, p2,p3,p4, ackSign) = {
    
        if (agentType == "boss" and secretKey == "secretkey_employer") {
            // agent (Employer) has been identified
            pay!(*p1, *p2,*p3,*p4,*invoiceId, *invoiceName, *invoiceAmount, "Joe", amount ,"Hello " ++ agentType ++ " you just paid Joe. transaction fullfiled using your key ${secretKey}" %% {"secretKey": secretKey}, *ackPay)| 
            for (@aa <- ackPay) {
                ackSign!(aa)
            }
        }
    } |

    // identify someone using RhobustContract
    contract RhobustContractSign(@agentType, @secretKey, ackSign) = {
    
        if (agentType == "boss" and secretKey == "secretkey_employer") {
            // agent (Employer) has been identified
            logResolve!("Hello " ++ agentType ++ ", you will pay soon. transaction will be fullfiled using your key ${secretKey}" %% {"secretKey": secretKey}, *ackSign)
        
        } else 
        if (agentType == "Joe" and secretKey == "secretkey_employee") {
            // agent (Employee) has been identified
            logResolve!("Hello " ++ agentType ++ ", you will get payed soon. transaction will be fullfiled using your key ${secretKey}" %% {"secretKey": secretKey}, *ackSign)
        }  else 
        if (agentType == "coop" and secretKey == "secretkey_coop") {
            // agent (Employee) has been identified
            logResolve!("Hello " ++ agentType ++ ", you will get payed soon. transaction will be fullfiled using your key ${secretKey}" %% {"secretKey": secretKey}, *ackSign)
        }  else 
        if (agentType == "irs" and secretKey == "secretkey_irs") {
            // agent (IRS) has been identified
            logResolve!("Hello " ++ agentType ++ ", tax income will be transfered soon. transaction will be fullfiled using your key ${secretKey}" %% {"secretKey": secretKey}, *ackSign)
        } else {
            // NOTHING happens otherwise
        }
    } |
    
    // get the uri of this RhobustContract from the registry
    contract RhobustContract(this, @"register", @[*ret]) = {
        new RhobustContractChan, uriChan in {
            for( @RhobustContract <- this) {
                if (RhobustContract.get("uri") != Nil ) {
                    stdout!(["RhobustContract",RhobustContract.get("uri")]) |
                    ret!(RhobustContract.get("uri")) |
                    this!(RhobustContract)
                } else {
                    ri!(*this, *uriChan) |
                    for(@uri <- uriChan) {
                        stdout!(["RhobustContract",uri]) |
                        this!(RhobustContract.set("uri",uri)) |
                        ret!(uri)
                    }
                }
            }
        }
    } | 
    
    // Helper contract
    contract Object(class, @instance, ret) = {
        new this in {
            ret!(bundle+{*this}) |
            //instance methods
            contract this(@method, args) = {
                class!(instance, method, *args)
            }
        }
    } |
    
    // simple log method
    contract logResolve(@message, cb) = {
        cb!(message)
    } |
    
    // simple log methodH, "payment", name, "employer", amount," << salary payed ! (AGENT A)"
    contract logTransaction(@tid,@action,@nameWorker,@nameCurrentAgent,@amount,@message)= {
        stdout!(["transaction id:",tid,"action:",action,"nameCurrentAgent:",nameCurrentAgent,"amount:",amount,"message:",message])
    } |

    // agent A (Employer) behaviour : pay
    contract pay(p1, p2, p3, p4, pId, pName, pAmount, @name,@amount,@message, ackEnd) = {
        new Y, H in {
        // generate new transaction hash key
        @"keccak256Hash"!(name.toByteArray(), *Y) 
            |  // <- concurrent key generation and key receiver channel creation
            for (@H <- Y) { // we have a key

                @[*p1, "directpayment"]!(amount, *p2, *ccDep1, *ccDep2) |
                for (@aa <- ccDep1; @bb <- ccDep2) {
                    
                    logTransaction!(H, "payment", name, "employer", amount," << salary payed ! (AGENT A)") | 
                    // fullfill the payment
                    pId!(H) | pName!(name) | pAmount!(amount) |

                    for(@paymentId <- invoiceId;@paymentName <- invoiceName;@amount <- invoiceAmount) {
                        // the payment has been done.
                        
                        // agent B (Employee) pays his taxes
                        @[*p2, "directpayment"]!(amount/2, *p3, *sccDep1, *sccDep2) |
                        
                        // agent A  pays Coop
                        @[*p1, "directpayment"]!(1, *p4, *sccDep3, *sccDep4) |
                        
                        // agent B  pays Coop
                        @[*p2, "directpayment"]!(1, *p4, *sccDep5, *sccDep6) |
                        
                        // agent C  pays Coop
                        @[*p3, "directpayment"]!(1, *p4, *sccDep7, *sccDep8) |
                        
                        for (@a1 <- sccDep1; @b2 <- sccDep2;@c3 <- sccDep3; @d4 <- sccDep4;@e5 <- sccDep5; @f6 <- sccDep6;@g7 <- sccDep7; @h8 <- sccDep8) {
                            ackEnd!({"a":a1,"b":b2,"c":H})
                        } 
                        
                    }
                }
            }
        }
    } 
}