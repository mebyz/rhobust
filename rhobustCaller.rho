// emmanuel.botros@gmail.com

contract @"rhobustFactory102"(rhobustContract, @n) = {
    new pay, invoiceId, invoiceAmount, invoiceName, processIncomeTax, widthdraw, taxPay,
    ri(`rho:registry:insertArbitrary`), 
    rl(`rho:registry:lookup`),
    stdout(`rho:io:stdout`),
    stdoutAck(`rho:io:stdoutAck`), ack, countCh, logResolve, logTransaction in {
        
        // simple log method
        contract logResolve(@message, cb) = {
            cb!(message)
        } |
        
        // simple log methodH, "payment", name, "employer", amount," << salary payed ! (AGENT A)"
        contract logTransaction(@tid,@action,@nameWorker,@nameCurrentAgent,@amount,@message)= {
            stdout!(["transaction id:",tid,"action:",action,"nameWorker:",nameWorker,"nameCurrentAgent:",nameCurrentAgent,"amount:",amount,"message:",message])
        } |

        // rhobust contract
        contract rhobustContract(@agentType, @secretKey, result) = {
            //countCh!(1) |
            //for(@oldCount <- countCh) {
                if (agentType == "boss" and secretKey == "secretkey_employer") {
                    // agent A (Employer) has been identified
                    pay!(*invoiceId, *invoiceName, *invoiceAmount, "Joe", 100)
                    |  // <- concurrent
                    logResolve!("Hello " ++ agentType ++ ", let's pay Joe. transaction will be fullfiled using your key ${secretKey}" %% {"secretKey": secretKey}, *result)
                } else 
                if (agentType == "Joe" and secretKey == "secretkey_employee") {
                    // agent B (Employee) has been identified
                    logResolve!("Hello " ++ agentType ++ ", you will get payed soon. transaction will be fullfiled using your key ${secretKey}" %% {"secretKey": secretKey}, *result)
                }  else 
                if (agentType == "irs" and secretKey == "secretkey_irs") {
                    // agent C (IRS) has been identified
                    logResolve!("Hello " ++ agentType ++ ", tax income will be transfered soon. transaction will be fullfiled using your key ${secretKey}" %% {"secretKey": secretKey}, *result)
                } else {
                    // NOTHING happens otherwise
                }
            //}
        }|

        // when a payment occurs, these three actions are triggered .. CONCURRENTLY !!
        for(@paymentId <- invoiceId;@paymentName <- invoiceName;@amount <- invoiceAmount) {
            // required inputs have matched ! the payment has been done.
            
            // agent B (Employee)
            widthdraw!(paymentId, paymentName, amount/2, *ack)
            |  // <- concurrent
            // agent B (Employee)
            taxPay!(paymentId, paymentName, amount/2, *ack)
            |  // <- concurrent         
            // agent C (Tax Services)
        	processIncomeTax!(paymentId, paymentName, amount/2, *ack)      
        } |

        // agent A (Employer) behaviour : pay
        contract pay(pId, pName, pAmount, @name,@amount) = {
            new Y, H in {
              // generate new transaction hash key
              @"keccak256Hash"!(name.toByteArray(), *Y) 
                |  // <- concurrent key generation and key receiver channel creation
              for (@H <- Y) { // we have a key
              	logTransaction!(H, "payment", name, "employer", amount," << salary payed ! (AGENT A)")
              	| 
                pId!(H) | pName!(name) | pAmount!(amount) // fullfill the payment (4 independent processes are spawned)
              }
                }
        } |

        // agent B (Employee) behaviour : widthdraw
        contract widthdraw(@uri,@name,@amount, result) = {
            new paymentIdLookupResponse in {
                // todo : code the widthdraw of @amount salary 
              	logTransaction!(uri, "withdraw", name, "employee", amount, " << got payment. can widthdraw ! (AGENT B)") |
              	result!("ok")
            }
        }|

        // agent B (Employee) behaviour : taxPay
        contract taxPay(@uri,@name,@amount, result) = {
            new taxPaymentOut in {
                // todo : code the payment of @amount of taxes
              	logTransaction!(uri, "tax_payment", name, "employee", amount, " << tax payed ! (AGENT B)") |
              	result!("ok")
            }
        }|

        // agent C (Tax Services) behaviour : processIncomeTax
        contract processIncomeTax(@uri,@name,@amount, result) = {
            new taxPaymentIn in {
                // todo : code the income of @amount taxes 
              	logTransaction!(uri, "tax_income", name, "IRS", amount, " << tax secured ! (AGENT C)") |
              	result!("ok")
            }
        }
    }
} |

// myRhobustContractTEST : test rhobustFactory102
// This level of recursivity is only needed to simulate a sequential test.
// In real life, agents interact INDEPENDENTLY and sometimes CONCURRENTLY.
new myRhobustContractTEST, ack, stdoutAck(`rho:io:stdoutAck`) in {
  stdoutAck!("TEST : Creating sample rhobust contract", *ack) | 
  @"rhobustFactory102"!(*myRhobustContractTEST, 3) | 
  for(_ <- ack) {
    myRhobustContractTEST!("Joe", "secretkey_employee", *ack) | 
    for(res <- ack) {
      stdoutAck!(*res, *ack) | 
      for(_ <- ack) {
        myRhobustContractTEST!("irs", "secretkey_irs", *ack) | 
        for(res <- ack) {
          stdoutAck!(*res, *ack) | 
          for(_ <- ack) {
            myRhobustContractTEST!("boss", "secretkey_employer" , *ack) | 
            for(res <- ack) {
              stdoutAck!(*res, *ack) | 
              for(_ <- ack) {
                myRhobustContractTEST!("Sam", "dummy_key", *ack) | 
                for(res <- ack) {
                  stdoutAck!(*res, *ack)
                }
              }
            }
          }
        }
      }
    }
  }
}
    