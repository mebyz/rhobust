// emmanuel.botros@gmail.com

new
doubler,
  uriChan,
  contractCh,ct,

stdout(`rho:io:stdout`),
ri(`rho:registry:insertArbitrary`), 
rl(`rho:registry:lookup`),
stdoutAck(`rho:io:stdoutAck`),
RhobustContract,
Object, 
super,
ackContract, 
ackJoe,
resJoe, 
ackIrs,
resIrs, 
ackBoss,
resBoss, 
ackInfo,
resInfo,
ackRegister,
resRegister,
ackRl,
resRl,
ack, 
pay, 
invoiceId, 
invoiceAmount, 
invoiceName, 
processIncomeTax, 
widthdraw, 
taxPay, 
logResolve, 
uriChan,
uriChan2,
uri2,
logTransaction,resgettest,ackgettest,ct2,contractCh2
in {
    
    // TEST RhobustContract
    // This level of recursivity is only needed to simulate a sequential test.
    // In real life, agents interact INDEPENDENTLY and sometimes CONCURRENTLY.
    stdoutAck!("TEST : Creating sample rhobust contract", *ack) |
    stdout!(["RhobustContract: ",*RhobustContract]) |
    // store the contracts
    ri!(bundle+{*RhobustContract}  , *uriChan) |
    // Wait for URI response
    for(@uri <- uriChan) {
        stdout!(uri) | 
        // lookup again using uri
        rl!(uri, *contractCh) |
        for( ct <- contractCh) {
            ct!("new",[Nil,{"title": uri, "data": true},*ackContract]) |
            for ( myContract <- ackContract) { 
                stdout!("OK")|
                // store the instance of the contract
                ri!(bundle+{*myContract}  , *uriChan2) |
                // Wait for URI response
                for(@uri2 <- uriChan2) {
                    stdout!(uri2)|
                    // lookup again using uri
                     rl!(uri2, *contractCh2) |
                     for( ct2 <- contractCh2) {
                        stdout!(*ct2)|
                        ct2!("identify", ["Joe","secretkey_employee", *ackJoe]) |
                        for(resJoe <- ackJoe) {
                            stdout!(*resJoe) |
                            ct2!("identify", ["irs","secretkey_irs", *ackIrs]) |
                            for(resIrs <- ackIrs) {
                                stdout!(*resIrs) |
                                ct2!("identify", ["boss","secretkey_employer", *ackBoss]) |
                                for(resBoss <- ackBoss) {
                                    stdout!(*resBoss)
                                    //payment done
                                }
                            }
                        }
                     }
                }
            }
      }
    } |
    
    // class method to create a new RhobustContract
    contract RhobustContract(@"new", @[ 
        super, 
        propsMap,
        *return]) = { // return the address (name/channel) of the new RhobustContract Object
            new instance, ret in {
            stdout!(["new",{"props": propsMap}, *instance]) |
            Object!(*RhobustContract, *instance, *ret) |
            for ( @object <- ret ) {
                instance!({"object": object, "contract": bundle+{*RhobustContract}, "props": propsMap }) |
                return!(object)
            }
        }
    } |

    // get a property value from this RhobustContract
    contract RhobustContract(this, @"get", @[name, *value]) = {
        for (@nod <- this) {
            this!(nod) |
            value!(nod.get("props").get(name))
        }
    } |
    // get a property value from this RhobustContract
    contract RhobustContract(this, @"gettest", @[*ack]) = {
        for (@nod <- this) {
            ack!("ok ok ok ok")
        }        
    } |

    // set a property value from this RhobustContract
    contract RhobustContract(this, @"set", @[name, value, *ack]) = {
        for (@nod <- this) {
            this!(nod.set("props",nod.get("props").set(name,value))) |
            ack!(Nil)
        }
    } |

    // identify someone using RhobustContract
    contract RhobustContract(this, @"identify", @[agentType, secretKey, *ack]) = {
        for (@nod <- this) {
            this!(nod) |
            if (agentType == "boss" and secretKey == "secretkey_employer") {
                // agent A (Employer) has been identified
                pay!(*invoiceId, *invoiceName, *invoiceAmount, "Joe", 100)
                |  // <- concurrent
                logResolve!("Hello " ++ agentType ++ ", let's pay Joe. transaction will be fullfiled using your key ${secretKey}" %% {"secretKey": secretKey}, *ack)
            } else 
            if (agentType == "Joe" and secretKey == "secretkey_employee") {
                // agent B (Employee) has been identified
                logResolve!("Hello " ++ agentType ++ ", you will get payed soon. transaction will be fullfiled using your key ${secretKey}" %% {"secretKey": secretKey}, *ack)
            }  else 
            if (agentType == "irs" and secretKey == "secretkey_irs") {
                // agent C (IRS) has been identified
                logResolve!("Hello " ++ agentType ++ ", tax income will be transfered soon. transaction will be fullfiled using your key ${secretKey}" %% {"secretKey": secretKey}, *ack)
            } else {
                // NOTHING happens otherwise
            }
        }
    } |
    
    // get the uri of this RhobustContract from the registry
    contract RhobustContract(this, @"register", @[*ret]) = {
        new RhobustContractChan, uriChan in {
            for( @RhobustContract <- this) {
                if (RhobustContract.get("uri") != Nil ) {
                    stdout!(["RhobustContract",RhobustContract.get("uri")]) |
                    ret!(RhobustContract.get("uri")) |
                    this!(RhobustContract)
                } else {
                    ri!(*this, *uriChan) |
                    for(@uri <- uriChan) {
                        stdout!(["RhobustContract",uri]) |
                        this!(RhobustContract.set("uri",uri)) |
                        ret!(uri)
                    }
                }
            }
        }
    } | 
    
    // Helper contract
    contract Object(class, @instance, ret) = {
        new this in {
            ret!(bundle+{*this}) |
            //instance methods
            contract this(@method, args) = {
                class!(instance, method, *args)
            }
        }
    } |
    
    // simple log method
    contract logResolve(@message, cb) = {
        cb!(message)
    } |
    
    // simple log methodH, "payment", name, "employer", amount," << salary payed ! (AGENT A)"
    contract logTransaction(@tid,@action,@nameWorker,@nameCurrentAgent,@amount,@message)= {
        stdout!(["transaction id:",tid,"action:",action,"nameWorker:",nameWorker,"nameCurrentAgent:",nameCurrentAgent,"amount:",amount,"message:",message])
    } |

    // when a payment occurs, these three actions are triggered .. CONCURRENTLY !!
    for(@paymentId <- invoiceId;@paymentName <- invoiceName;@amount <- invoiceAmount) {
        // required inputs have matched ! the payment has been done.
        
        // agent B (Employee)
        widthdraw!(paymentId, paymentName, amount/2, *ack)
        |  // <- concurrent
        // agent B (Employee)
        taxPay!(paymentId, paymentName, amount/2, *ack)
        |  // <- concurrent         
        // agent C (Tax Services)
        processIncomeTax!(paymentId, paymentName, amount/2, *ack)      
    } |

    // agent A (Employer) behaviour : pay
    contract pay(pId, pName, pAmount, @name,@amount) = {
        new Y, H in {
        // generate new transaction hash key
        @"keccak256Hash"!(name.toByteArray(), *Y) 
            |  // <- concurrent key generation and key receiver channel creation
        for (@H <- Y) { // we have a key
            logTransaction!(H, "payment", name, "employer", amount," << salary payed ! (AGENT A)")
            | 
            pId!(H) | pName!(name) | pAmount!(amount) // fullfill the payment (4 independent processes are spawned)
        }
            }
    } |

    // agent B (Employee) behaviour : widthdraw
    contract widthdraw(@uri,@name,@amount, result) = {
        new paymentIdLookupResponse in {
            // todo : code the widthdraw of @amount salary 
            logTransaction!(uri, "withdraw", name, "employee", amount, " << got payment. can widthdraw ! (AGENT B)") |
            result!("ok")
        }
    }|

    // agent B (Employee) behaviour : taxPay
    contract taxPay(@uri,@name,@amount, result) = {
        new taxPaymentOut in {
            // todo : code the payment of @amount of taxes
            logTransaction!(uri, "tax_payment", name, "employee", amount, " << tax payed ! (AGENT B)") |
            result!("ok")
        }
    }|

    // agent C (Tax Services) behaviour : processIncomeTax
    contract processIncomeTax(@uri,@name,@amount, result) = {
        new taxPaymentIn in {
            // todo : code the income of @amount taxes 
            logTransaction!(uri, "tax_income", name, "IRS", amount, " << tax secured ! (AGENT C)") |
            result!("ok")
        }
    }
}