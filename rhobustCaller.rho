    // emmanuel.botros@gmail.com
/////////////////////////
// myRhobustContractTEST : test rhobustFactory102

new myRhobustContractTEST, ack, stdoutAck(`rho:io:stdoutAck`),
ackJoe, resJoe, 
ackIrs, resIrs, 
ackBoss, resBoss,
resProc_Joe,ackProc_Joe,
resProc_Irs,ackProc_Irs,
resProc_Boss,ackProc_Boss in {

import MakeMint, TestSet in {
  MakeMint!("mintA") | MakeMint!("mintB") |
 |
  for(mintA <- @"mintA"; mintB <- @"mintB") {
    mintA!("makePurse", [100], "aliceAPurse") | mintB!("makePurse", [50], "bobBPurse") |
    for(@aliceAPurse <- @"aliceAPurse"; @bobBPurse <- @"bobBPurse") {
      TestSet!(
        "Purses should be created with the given balance.",
        [
          [aliceAPurse, "getBalance", [], 100],
          [bobBPurse, "getBalance", [], 50]
        ]
      ) |
      @[*TestSet, "after"]!("Purses should be created with the given balance.", {
        TestSet!( //cannot deposit tokens across different mints
          "Cross-currency deposits should fail.",
          [
            [aliceAPurse, "deposit", [10, bobBPurse], false],
            [bobBPurse, "deposit", [10, aliceAPurse], false],
          ]
        )
      }) |
      @[*TestSet, "after"]!("Cross-currency deposits should fail.", {
        @aliceAPurse!("sprout", [], "bobAPurse") |
        @bobBPurse!("sprout", [], "aliceBPurse") |
        for(@aliceBPurse <- @"aliceBPurse"; @bobAPurse <- @"bobAPurse") {
          TestSet!(
            "Deposit should work as expected.",
            [
              [aliceBPurse, "deposit", [10, bobBPurse], true], //10 from Bob to Alice
              [aliceBPurse, "getBalance", [], 10], //0 + 10 = 10
              [bobBPurse, "getBalance", [], 40], // 50 - 10 = 40
              
              [bobAPurse, "deposit", [20, aliceAPurse], true], //20 from Alice to Bob
              [bobAPurse, "getBalance", [], 20], //0 + 20 = 20
              [aliceAPurse, "getBalance", [], 80], // 100 - 20 = 80
              
              [bobAPurse, "deposit", [30, aliceAPurse], true], //30 from Alice to Bob again
              [bobAPurse, "getBalance", [], 50], //20 + 30 = 50
              [aliceAPurse, "getBalance", [], 50], // 80 - 30 = 50
            ]
          )
        }
      })
    }
  } |
  stdoutAck!("TEST : Creating sample rhobust contract. 3 agents (employer, employee, IRS)", *ack)
    |  // <- concurrent (log test start)
  // TEST RhobustContracts
    // The level of recursivity shown in this test is needed to simulate sequential actions of each agent
    // In real life, agents interact INDEPENDENTLY and sometimes CONCURRENTLY.
    // in Rholang, concurrency is handled gracefully. this is why simulating sequencial actions is harder ^^
    new myRhobustContractTEST, myRhobustContract_Joe , myRhobustContract_Irs , myRhobustContract_Boss, ack,
    stdout(`rho:io:stdout`), stdoutAck(`rho:io:stdoutAck`) in {
      stdout!("TEST STEP 1 : Creating sample rhobust contract") | 
      @"RhobustFactory"!(*myRhobustContractTEST, 3, *ack) |
      for(@uri2 <- ack) {
        //stdout!(uri2) |

        // uri2 is sent to all 3 agents.

        // Agent A (Joe) stores uri2 in a safe place
        // Agent B (IRS) stores uri2 in a safe place
        // Agent C (boss) stores uri2 in a safe place

        
        // Later on, agent A (Joe) logs in to sign the contract
        // this results in a lookup in the tuplespace using uri
        @"RhobustFactory"!(*myRhobustContract_Joe, uri2,"sign", "Joe","secretkey_employee", *ackJoe) |
        for(resJoe <- ackJoe) {
            stdout!(*resJoe) |
        
                
            
            // Later on, agent B (irs) logs in to sign the contract
            // this results in a lookup in the tuplespace using uri
            @"RhobustFactory"!(*myRhobustContract_Irs, uri2,"sign",  "irs","secretkey_irs", *ackIrs) |
            for(resIrs <- ackIrs) {
                stdout!(*resIrs) | 
                    
                    
                    
                // Later on, agent C (boss) logs in to sign the contract
                // this results in a lookup in the tuplespace using uri
                @"RhobustFactory"!(*myRhobustContract_Boss, uri2,"sign",  "boss","secretkey_employer", *ackBoss) |
                for(resBoss <- ackBoss){
                    stdout!(*resBoss) 
                    
                    // identification done for boss
                    // + payment done (lots of thing happened)
                    
                    }
                }
            }
        }
    }
}
} |
new
stdout(`rho:io:stdout`),
ri(`rho:registry:insertArbitrary`), 
rl(`rho:registry:lookup`),
stdoutAck(`rho:io:stdoutAck`),
RhobustContract,
Object, 
contractCh,
ackContract,  
ackInfo,resInfo,
ackRegister,
resRegister,
ackRl,resRl,
ack, ackContractCh,
pay, ackPay,
invoiceId, invoiceAmount, invoiceName, 
processIncomeTax, widthdraw, taxPay, 
logResolve, 
uriChan, uriChan2, uri2,
logTransaction,
agentType,secretKey,
ackwithdraw,acktaxPay,ackprocessIncomeTax,
RhobustContractSign,ackRhobustContractSign
in {
    contract @"RhobustFactory"(rhobustCreation, @n, result) = {
        new 
        ri(`rho:registry:insertArbitrary`), 
        rl(`rho:registry:lookup`) in {
        // store the contracts
        ri!(bundle+{*RhobustContract}  , *uriChan) |
        for(@uri <- uriChan) {
            // lookup again using uri
            rl!(uri, *contractCh) |
            for( ct <- contractCh) {
                ct!("new",[{"contract_id": uri, "data": true},*ackContract]) |
                for ( myContract <- ackContract) { 
                    // store the instance of the contract
                    ri!(bundle+{*myContract}  , *uriChan2) |
                    for(@uri2 <- uriChan2) {
                        // send back the final contract instance uri
                        result!(uri2)
                    }
                }
            }
        }
        }
    } |

    contract @"RhobustFactory"(rhobustLookup, @uri, @action, @name, @key, resultLookup) = {
        rl!(uri, *ackContractCh) |
        for( ctInstance <- ackContractCh) {
            ctInstance!(name, key, *ackRhobustContractSign) | 
            for(@resRhobustContractSign <- ackRhobustContractSign) {
                resultLookup!(resRhobustContractSign)
            }
        }

    } |
    
    // class method to create a new RhobustContract
    contract RhobustContract(@"new", @[
        propsMap,
        *return]) = { // return the address (name/channel) of the new RhobustContract Object
            new instance, ret in {
            stdout!(["new",{"props": propsMap}, *instance]) |
            Object!(*RhobustContract, *instance, *ret) |
            for ( @object <- ret ) {
                instance!({"object": object, "contract": bundle+{*RhobustContract}, "props": propsMap }) |
                return!(object)
            }
        }
    } |

    // get a property value from this RhobustContract
    contract RhobustContract(this, @"get", @[name, *value]) = {
        for (@nod <- this) {
            this!(nod) |
            value!(nod.get("props").get(name))
        }
    } |

    // set a property value from this RhobustContract
    contract RhobustContract(this, @"set", @[name, value, *ack]) = {
        for (@nod <- this) {
            this!(nod.set("props",nod.get("props").set(name,value))) |
            ack!(Nil)
        }
    } |

    // identify someone using RhobustContract
    contract RhobustContractSign(@agentType, @secretKey, ackSign) = {
    
        if (agentType == "boss" and secretKey == "secretkey_employer") {
            // agent A (Employer) has been identified
            pay!(*invoiceId, *invoiceName, *invoiceAmount, "Joe", 100,"Hello " ++ agentType ++ " you just paid Joe. transaction fullfiled using your key ${secretKey}" %% {"secretKey": secretKey}, *ackPay)
            |
            for (@hs<- ackPay) {
                ackSign!(hs)
            }
        } else 
        if (agentType == "Joe" and secretKey == "secretkey_employee") {
            // agent B (Employee) has been identified
            logResolve!("Hello " ++ agentType ++ ", you will get payed soon. transaction will be fullfiled using your key ${secretKey}" %% {"secretKey": secretKey}, *ackSign)
        }  else 
        if (agentType == "irs" and secretKey == "secretkey_irs") {
            // agent C (IRS) has been identified
            logResolve!("Hello " ++ agentType ++ ", tax income will be transfered soon. transaction will be fullfiled using your key ${secretKey}" %% {"secretKey": secretKey}, *ackSign)
        } else {
            // NOTHING happens otherwise
        }
    } |
    
    // get the uri of this RhobustContract from the registry
    contract RhobustContract(this, @"register", @[*ret]) = {
        new RhobustContractChan, uriChan in {
            for( @RhobustContract <- this) {
                if (RhobustContract.get("uri") != Nil ) {
                    stdout!(["RhobustContract",RhobustContract.get("uri")]) |
                    ret!(RhobustContract.get("uri")) |
                    this!(RhobustContract)
                } else {
                    ri!(*this, *uriChan) |
                    for(@uri <- uriChan) {
                        stdout!(["RhobustContract",uri]) |
                        this!(RhobustContract.set("uri",uri)) |
                        ret!(uri)
                    }
                }
            }
        }
    } | 
    
    // Helper contract
    contract Object(class, @instance, ret) = {
        new this in {
            ret!(bundle+{*this}) |
            //instance methods
            contract this(@method, args) = {
                class!(instance, method, *args)
            }
        }
    } |
    
    // simple log method
    contract logResolve(@message, cb) = {
        cb!(message)
    } |
    
    // simple log methodH, "payment", name, "employer", amount," << salary payed ! (AGENT A)"
    contract logTransaction(@tid,@action,@nameWorker,@nameCurrentAgent,@amount,@message)= {
        stdout!(["transaction id:",tid,"action:",action,"nameCurrentAgent:",nameCurrentAgent,"amount:",amount,"message:",message])
    } |

    // agent A (Employer) behaviour : pay
    contract pay(pId, pName, pAmount, @name,@amount,@message, ackEnd) = {
        new Y, H in {
        // generate new transaction hash key
        @"keccak256Hash"!(name.toByteArray(), *Y) 
            |  // <- concurrent key generation and key receiver channel creation
        for (@H <- Y) { // we have a key
            logTransaction!(H, "payment", name, "employer", amount," << salary payed ! (AGENT A)")
            | 
            // fullfill the payment (4 independent processes are spawned)
            pId!(H) | pName!(name) | pAmount!(amount) |

            ackEnd!([H,message,name,amount]) |
            
            // when a payment occurs, these three actions are triggered .. CONCURRENTLY !!
            for(@paymentId <- invoiceId;@paymentName <- invoiceName;@amount <- invoiceAmount) {
                // required inputs have matched ! the payment has been done.
                
                // agent B (Employee)
                widthdraw!(paymentId, paymentName, amount/2, *ackwithdraw) |
                for(@wd <- ackwithdraw) {
                    stdout!(wd)
                }
                |  // <- concurrent
                // agent B (Employee)
                taxPay!(paymentId, paymentName, amount/2, *acktaxPay) |
                for(@tp <- acktaxPay) {
                    stdout!(tp)
                }
                |  // <- concurrent         
                // agent C (Tax Services)
                processIncomeTax!(paymentId, paymentName, amount/2, *ackprocessIncomeTax) |
                for(@it <- ackprocessIncomeTax) {
                    stdout!(it)
                }  
            }
        }
            }
    } |

    // agent B (Employee) behaviour : widthdraw
    contract widthdraw(@uri,@name,@amount, result_widthdraw) = {
        new paymentIdLookupResponse in {
            // todo : code the widthdraw of @amount salary 
            logTransaction!(uri, "withdraw", name, "employee", amount, " << got payment. can widthdraw ! (AGENT B)") |
            result_widthdraw!("ok_withdraw")
        }
    }|

    // agent B (Employee) behaviour : taxPay
    contract taxPay(@uri,@name,@amount, result_taxPay) = {
        new taxPaymentOut in {
            // todo : code the payment of @amount of taxes
            logTransaction!(uri, "tax_payment", name, "employee", amount, " << tax payed ! (AGENT B)") |
            result_taxPay!("ok_taxpay")
        }
    }|

    // agent C (Tax Services) behaviour : processIncomeTax
    contract processIncomeTax(@uri,@name,@amount, result_processIncomeTax) = {
        new taxPaymentIn in {
            // todo : code the income of @amount taxes 
            logTransaction!(uri, "tax_income", name, "IRS", amount, " << tax secured ! (AGENT C)") |
            result_processIncomeTax!("ok_processtax")
        }
    }
}
}